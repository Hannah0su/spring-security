# spring-security

# 1장

# 오늘날의 보안

- [1.1 스프링 시큐리티: 개념과 장점](#11-스프링-시큐리티-개념과-장점)

- [1.2 소프트웨어 보안이란?](#12-소프트웨어-보안이란)

- [1.3 보안이 중요한 이유는 무엇인가?](#13-보안이-중요한-이유는-무엇인가)

- [1.4 웹 애플리케이션의 일반적인 보안 취약성](#14-웹-애플리케이션의-일반적인-보안-취약성)

- [1.4.1 인증과 권한 부여의 취약성](#141-인증과-권한-부여의-취약성)

- [1.4.2 세션 고정](#142-세션-고정)

- [1.4.3 XSS(교차 사이트 스크립팅)](#143-xss교차-사이트-스크립팅)

- [1.4.4 CSRF(사이트 간 요청 위조)](#144-csrf사이트-간-요청-위조)

- [1.4.5 주입(Injection)](#145-주입injection)

- [1.4.6 기밀 데이터 노출](#146-기밀-데이터-노출)

- [1.4.7 메서드 접근 제어 부족](#147-메서드-접근-제어-부족)

- [1.4.8 알려진 취약성이 있는 종속성 이용](#148-알려진-취약성이-있는-종속성-이용)

- [1.5 다양한 아키텍처에 적용된 보안](#15-다양한-아키텍처에-적용된-보안)

- [1.5.1 일체형 웹 애플리케이션 설계](#151-일체형-웹-애플리케이션-설계)

- [1.5.2 백엔드/프론트엔드 분리를 위한 보안 설계](#152-백엔드프론트엔드-분리를-위한-보안-설계)

- [1.5.3 OAuth2](#153-oauth2)

- [1.5.4 API 키, 암호화 서명, IP 검증을 이용한 요청 보안](#154-api-키-암호화-서명-ip-검증을-이용한-요청-보안)

## 1.1 스프링 시큐리티: 개념과 장점

스프링 시큐리티는 스프링 애플리케이션에서 애플리케이션 수준의 보안을 구현할 때 가장 우선적인 선택이며 **인증, 권한 부여 및 일반적인 공격에 대한 방어**를 구현하는 세부적인 맞춤 구성 방법을 제공한다.

어노테이션, 빈, 그리고 스프링 방식의 구성스타일을 통해 어플리케이션 수준의 보안을 정의할 수 있다.

일반적으로 **누가 작업을 수행하는지, 특정 데이터를 이용할 수 있는지**를 결정한다.

구성을 기반으로 요청을 가로채고 권한을 가진 사용자만 보호된 리소스에 접근할 수 있도록 스프링 시큐리티 구성 요소를 작성한다.
또한 구성 요소는 시스템의 다른 부분 간의 데이터 전송 및 저장 시 이 다른 부분에 대한 호출을 가로채서 데이터에 작업을 수행한다.

>ex) 암호화, 해싱 알고리즘 적용과 데이터 인코딩으로 인가 수행

스프링 시큐리티를 이해하고 올바르게 이용하는 것은 개발자의 책임이다.
스프링 시큐리티를 도입하기만 한다고해서, 자동으로 보호해주는 것이 아니다.

**나의 역량에 따라서 우체통에 열쇠를 숨기는 수준에서 다중 도어락과 CCTV를 설치하는 수준까지 차이가 날 수 있다.**


## 1.2 소프트웨어 보안이란?

현재의 소프트웨어 시스템은 민감한 정보일 수 있는 대량의 데이터를 관리한다. 

민감한 정보에는 전화번호, 이메일 주소 등의 비교적 무해한 정보도 있지만, 유출됐을 때 위험성이 큰 신용카드 정보, 주민등록번호 등도 존재한다.

애플리케이션은 이러한 정보에 접근, 변경, 인터셉트의 기회가 없게 해야 하며 의도된 사용자 이외의 대상은 어떤 식으로든 데이터와 상호작용할 수 없게 해야한다.

보안은 계층별로 적용해야하며 각 계층에 다른 접근 방식이 필요하다.

애플리케이션 수준 보안은 애플리케이션이 실행되는 환경과 애플리케이션이 처리하고 저장하는 데이터를 보호하기 위해 해야하는 모든것을 나타낸다.

![image](https://github.com/Hannah0su/spring-security/assets/83005178/b21b8a4e-86ba-4036-a932-5fca788536c7)

- 보안은 각 계층에 적용되고, 각 계층은 그 아래의 계층에 의존한다.

인증: 애플리케이션이 사용자를 식별하는 방법

인가: 인증된 사용자가 무엇을 하도록 허용해야하는지 결정

같은 구성요소의 다른 계층에도 권한 부여를 적용하는 것이 좋으며 데이터 저장시에도 개인키로 암호화한 데이터나 해시된 데이터로 저장해야한다.

마지막으로 실행중인 애플리케이션은 내부 메모리도 관리해야 한다.
애플리케이션의 힙에 저장된 데이터도 취약성의 원인일 수 있다.
앱이 자격 증명이나 개인 키 등의 민감한 데이터를 장시간 보관할 경우 힙 덤프 이용 권리가 있는 누군가가 악용할 수 있다.


## 1.3 보안이 중요한 이유는 무엇인가?

보안에 충분한 주의를 기울이지 않아, 사고가 발생하면 원치 않은 대가를 치뤄야 할 수 있다.

>ex) 서비스에 대한 이미지 하락, 금전적 비용등

## 1.4 웹 애플리케이션의 일반적인 보안 취약성

애플리케이션의 취약성(Vulnerability)

- 인증 취약성
- 세션 고정
- XSS(교차 사이트 스크립팅)
- CSRF(사이트 간 요청 위조)
- 주입
- 기밀 데이터 노출
- 메서드 접근 제어 부족
- 알려진 취약성이 있는 종속성 이용

### 1.4.1 인증과 권한 부여의 취약성


![image](https://github.com/Hannah0su/spring-security/assets/83005178/5eaba9a9-efae-44c2-b478-8ebb56cdcc47)

인증 취약성 : 사용자가 악의를 가지고 다른 사람의 기능이나 데이터에 접근할 수 있음

### 1.4.2 세션 고정

애플리케이션이 인증 프로세스 중에 고유한 세션 ID를 할당하지 않아 기존 세션 ID가 재사용될 가능성이 있을때 발생

ex)로그인 시 발급받은 세션 ID가 로그인 전/후 동일하게 사용되어, 공격자가 피해자의 세션을 하이재킹 하여 이용

세션 고정 취약성이 존재하면 공격자는 이미 생성된 세션 ID를 재이용해 유효한 사용자를 가장할 수 있다.

1. 공격자가 로그인 페이지에 접근하여 세션 ID를 획득한다.
2. 공격자는 획득한 세션 ID를 사용자에게 심는다. (세션 고정)
3. 사용자는 해당 세션 ID로 로그인한다.
4. 이후 피해자가 로그인하면, 서버는 피해자가 가진 세션 ID를 유효한 것으로 인식하고, 해당 세션 ID를 사용하여 서비스를 제공한다.
5. 공격자는 이전에 획득한 세션 ID를 사용하여 서비스에 접근하고, 피해자의 정보를 조회하거나 수정할 수 있다.


### 1.4.3 XSS(교차 사이트 스크립팅)

![image](https://github.com/Hannah0su/spring-security/assets/83005178/7c958be5-96c1-471d-b793-b6dade7fc77d)

서버에 노출된 웹 서비스로 클라이언트 쪽 스크립트를 주입해 다른 사용자가 이를 실행하도록 하는 공격

1. 해커가 악성 스크립트(앱 B를 공격하는 스크립트)가 포함된 댓글을 추가
2. 페이지의 방문자들에게 악성 스크립트 전달
3. 방문자들의 브라우저는 악성 스크립트를 실행하게 되고 의도치 않게 공격에 가담

### 1.4.4 CSRF(사이트 간 요청 위조)

![image](https://github.com/Hannah0su/spring-security/assets/83005178/a321dfda-aa9b-4c6b-8017-23b55804585d)

CSRF 공격은 특정 서버에서 작업을 호출하는 URL을 추출해 애플리케이션의 외부에서 재사용할 수 있다고 가정한다.

서버가 요청의 출처를 확인하지 않고 실행하면 다른 모든 곳에서 요청이 실행될 수 있다.

공격자는 CSRF를 통해 동작을 숨겨서 사용자가 서버에 원치 않는 동작을 실행하도록 할 수 있다.

### 1.4.5 주입(Injection)

공격자는 시스템에 특정 데이터를 주입하는 취약성을 이용한다.

주입 공격에는 여러 가지 유형이 있다. 앞서 언급한 XSS도 주입 취약성 중 하나로 볼 수 있다.

>ex) SQL Injection, XPath Injection, OS Command Injection, LDAP Injection ...

### 1.4.6 기밀 데이터 노출

기밀 데이터 공개는 기초적이고, 단순한 취약성이지만 흔한 실수 중 하나로 남아 있다.

>ex) 개인 키, 민감한 환경 변수 등

스프링의 구성 파일에서 설정하면, 소스 코드를 열람할 수있는 모든 사람이 접근할 수 있다.

한번 노출된 정보는 버전 관리 시스템에도 기록이 남는다.

또한 로그에도 공개 정보가 아닌 것은 기록하지 말아야 한다.

[예시]

```
[오류] 요청의 서명이 잘못 되었습니다. 사용할 올바른 키는 X입니다.
[경고] 사용자 이름 X와 암호 Y를 이용하여 로그인하지 못했습니다. 사용자 이름 X의 암호는 Z입니다.
[정보] 사용자 X가 올바른 암호 Y를 이용하여 로그인했습니다.
```

예외 발생 시에도 반환하는 메시지에 민감한 정보가 포함되면 안된다.

[예시]
```
Status : 500,
Error : 내부 서버 오류,
Message : IP 주소 **.*.*.*/8080에 대한 연결이 발견되지 않음.
EndPoint : /product/add
```

입력 값에 따라 다양한 메시지를 반환하는 것도 삼가해야한다.

[예시]
> ex)사용자 이름이 올바르지 않음, 암호가 올바르지 않음.
> 
> -> 사용자 이름 또는 암호가 올바르지 않음.

### 1.4.7 메서드 접근 제어 부족

애플레케이션 수준에서도 한 계층에서만 권한 부여를 적용하면 안 된다.

권한 부여가 특정한 한 계층에서만 실행되는 것이 아닌 애플리케이션의 모든 계층에 권한 부여를 적용해야한다.

>ex) Controller 계층에서만 권한 부여 X
> 
> → Controller, Service, Repository 전 계층에 권한 부여 구성

### 1.4.8 알려진 취약성이 있는 종속성 이용

알려진 취약점이 있는 종속성을 이용하지 않도록 조치를 취해야 한다.

## 1.5 다양한 아키텍처에 적용된 보안

소프트웨어 아키텍처가 서로 다르면 가능한 유출과 취약성이 서로 다르다.

따라서 보안 접근 방식에 영향을 미치는 다양한 요구 사항을 고려하면서 적용하여야 한다.

### 1.5.1 일체형 웹 애플리케이션 설계

![image](https://github.com/Hannah0su/spring-security/assets/83005178/aa1a0f70-798c-4312-8a04-36eb1c50535a)

백엔드/프론트엔드 직접적인 분리가 없는 경우

서버 세션 존재

→ 세션 고정 취약성, CSRF 가능성 고려
→ HTTP 세션하는 정보 고민

서버 세션은 준 영구적이며 데이터의 상태를 저장하므로 수명이 길다

→ 메모리에 유지되는 시간이 길수록 통계적으로 접근 가능성이 올라간다.

> ex) Heap Dump에 접근할 수 있는 사람은 앱의 내부 메모리에 있는 정보를 읽을 수 있다.

### 1.5.2 백엔드/프론트엔드 분리를 위한 보안 설계

![image](https://github.com/Hannah0su/spring-security/assets/83005178/9c60cd5d-c870-4abc-8403-80fea49a4b06)

일반적으로 서버 세션을 줄이고 클라이언트 쪽 세션으로 대체하는 것이 좋다.

→ CSRF 및 CORS 구성이 일반적으로 더 복잡하다.

### 1.5.3 OAuth2

![image](https://github.com/Hannah0su/spring-security/assets/83005178/0ca34a21-3cda-42b2-84c1-17576b73e535)

Oauth2 프레임워크는 권한 부여 서버와 리소스 서버를 정의한다.

권한 부여 서버 : 사용자에게 권한을 부여하고 사용자의 권리 집합을 지정하는 토큰 제공

리소스 서버 : 이 기능을 구현하는 백엔드 부분

1. 사용자가 애플리케이션의 기능에 접근. 애플리케이션은 백엔드의 리소스를 호출해야 한다.
2. 애플리케이션이 리소스 호출을 위해 먼저 액세스 토큰을 얻어야 한다. 권한 부여 서버를 호출하여 토큰을 얻는다.
3. 자격 증명이나 갱신 토큰의 검증 후 권한 부여 서버가 새로운 액세스 토큰을 반환한다.
4. 필요한 리소스 호출 시 리소스 서버에 대한 요청의 헤더에 액세스 토큰을 담는다.

OAuth2의 장점

- 클라이언트는 사용자 자격 증명을 저장할 필요 없이 액세스 토큰과 갱신 토큰만 저장하면 된다.
- 애플리케이션은 사용자 자격 증명을 네트워크 상에 노출하지 않는다.
- 누군가 토큰을 탈취하면 자격 증명을 무효로 할 필요 없이 토큰을 실격시킬 수 있다.
- 토큰을 이용하면 제삼자가 사용자를 가장하지 않고도 사용자 대신 리소스에 접근 가능하다
  - 공격자에게 토큰을 탈취당해도 토큰의 수명이 제한되므로, 취약점을 사용할 수 있는 기간이 제한적이다.

### 1.5.4 API 키, 암호화 서명, IP 검증을 이용한 요청 보안

![image](https://github.com/Hannah0su/spring-security/assets/83005178/bb865230-d6e7-4c64-9ae8-698e46ae386f)

호출자를 인증하고, 권한을 부여하기 위해 사용자 이름과 암호가 필요 없는 경우도 가끔 있지만, 이때도 교환되는 메시지를 변경할 수 없게 하고 싶을 수 있다.

- 요청 및 응답 헤더에 정적 키 이용
- 암호화 서명으로 요청 및 응답 서명
- IP 주소에 검증 적용